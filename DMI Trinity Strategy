// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© pidepython / https://www.fiverr.com/alighazanfer59/build-algotrading-backtesting-screening-data-tools

//@version=6
strategy("DMI Trintiy Strategy", overlay=true, default_qty_type=strategy.fixed, default_qty_value=2, calc_on_every_tick = true)

//========== PHASE 1: CORE FRAMEWORK ==========//

//--- 1. Timeframe Selection ---//
tf2 = input.bool(false, "2 Minutes", group="Timeframe Selection", inline="1")
tf3 = input.bool(false, "3 Minutes", group="Timeframe Selection", inline="1")
tf5 = input.bool(true, "5 Minutes", group="Timeframe Selection", inline="1")
tf15 = input.bool(true, "15 Minutes", group="Timeframe Selection", inline="2")
tf30 = input.bool(false, "30 Minutes", group="Timeframe Selection", inline="2")
tf60 = input.bool(false, "1 Hour", group="Timeframe Selection", inline="2")
tf240 = input.bool(false, "4 Hours", group="Timeframe Selection", inline="3")
tfD = input.bool(false, "Daily", group="Timeframe Selection", inline="3")


//--- 2. Condition Type Selection ---//
conditionType = input.string("DMI", "Condition Type", options=["DMI", "ADX"], group="Strategy Settings")

//--- 3. Indicator Parameters ---//
i_dmiLength = input.int(14, "Length", minval=1, group="DMI/ADX Settings")
i_dmiSmoothing = input.int(14, "Smoothing", minval=1, group="DMI/ADX Settings")
i_atrLength = input.int(10, "ATR Length", minval=1, group = "TASC Indicator Settings", tooltip = "TASC supertrend Calculation, a lower value will make the system more sensitive to trend reversal")
i_mult = input.float(3.0, "Multiplier", minval=0.1, step=0.1, group = "TASC Indicator Settings", tooltip = "TASC supertrend Calculation, a lower value will make the system more sensitive to trend reversal")

//--- 4. Trigger Conditions ---//
useTASC_SE = input.bool(false, "TASC Entry Signal", group="Trigger Settings")
useTASC_CE = input.bool(false, "TASC Continuation", group="Trigger Settings")

//--- 5. Trading Session ---//
in_time_sess_en = input.bool(true, "Limit trading hours?", group = "Time Settings")
in_time_sess = input.session("0930-1600", "Session hours", group = "Time Settings")
t = time(timeframe.period, in_time_sess)
time_sess_good = in_time_sess_en ? time == t : true
bgcolor((time == t and  in_time_sess_en) ? color.rgb(167, 175, 167) : na)

//--- 6. Trade Management ---//
i_contracts = input.int(2, "Contract Quantity", minval=1, group="Trade Management")
i_tp1_pts = input.int(20, "Take Profit (TP1) Points", minval=1, group="Trade Management")
i_tp2_pts = input.int(40, "Take Profit (TP2) Points", minval=1, group="Trade Management")
i_slPoints = input.int(20, "Stop Loss Points", minval=1, group="Trade Management")
i_breakeven_pts = input.int(3, "Breakeven Points", minval=0, group="Trade Management")
i_market_mv_to_BE = input.bool(false, "Enable Move to Breakeven", group="Trade Management")
i_pts_to_BE = input.int(10, "Points to Trigger Breakeven", group="Trade Management")
i_daily_profit_target = input.float(10000.0, "Daily Profit Target (USD)", minval=100.0, step = 100.0, group = "Trade Management")
i_daily_loss_limit = input.float(10000.0, "Daily Loss Limit (USD)", minval=100.0, step = 100.0, group = "Trade Management")


// === Daily PnL Tracking Based on End-of-Day Equity === //
var float equity_at_yesterday_close = na
var float equity_at_today_open = na
var float daily_pnl = 0.0
var bool can_trade_today = true

// Detect new day by change in dayofyear
var int last_day = dayofmonth
bool is_new_day = dayofmonth != last_day
if is_new_day
    equity_at_yesterday_close := nz(strategy.equity[1])
    equity_at_today_open := strategy.equity
    last_day := dayofmonth

// Update daily_pnl continuously throughout the day
daily_pnl := strategy.equity - equity_at_today_open

// Disable trading if outside limits
can_trade_today := (daily_pnl < i_daily_profit_target) and (daily_pnl > -i_daily_loss_limit)

// ======================================= INDICATOR CODE ============================================

// TASC calculation:

float multi  = i_mult  // (reuse the i_mult input)
int   length = i_atrLength  // (reuse the i_atrLength input)

[st, dir] = ta.supertrend(multi, length)

bool isNewTrend = ta.change(dir) != 0

plot(dir < 0 ? st : na, "Up direction", color = color.green, style=plot.style_linebr, linewidth = 3)
plot(dir > 0 ? st : na, "Down direction", color = color.red, style=plot.style_linebr, linewidth = 3)

// Trading signals
bool TASCbuyCondition = useTASC_SE ? isNewTrend and dir == -1 : true
bool TASCsellConditon = useTASC_SE ? isNewTrend and dir == 1 : true

// ===== PHASE 2: MTF DMI/ADX LOGIC ===== //
// Initialize condition arrays

// Create wrapper function for consistent DMI calculation
dmiWrapper(length, smoothing) =>
    [dip, din, adx] = ta.dmi(length, smoothing)
    [dip, din, adx]

var bool[] bullishConditions = array.new_bool()
var bool[] bearishConditions = array.new_bool()
var bool[] adxConditions = array.new_bool()

// Reset arrays on each bar
array.clear(bullishConditions)
array.clear(bearishConditions)
array.clear(adxConditions)

// Calculate MTF conditions
// if array.size(selectedTFs) > 0
//     for i = 0 to array.size(selectedTFs) - 1
//         string tf = array.get(selectedTFs, i)
        
// Get DMI/ADX values using wrapper function

[dip5m, din5m, adx5m] = request.security(syminfo.tickerid, '5', dmiWrapper(i_dmiLength, i_dmiSmoothing))
        
// Check conditions per timeframe
bool dmibuyCond5m = dip5m > din5m and dip5m >= 25
bool dmisellCond5m = dip5m < dip5m and din5m >= 25
bool adxbuyCond5m = dip5m > din5m and adx5m >= 25
bool adxsellCond5m = dip5m < din5m and adx5m >= 25

[dip15m, din15m, adx15m] = request.security(syminfo.tickerid, '15', dmiWrapper(i_dmiLength, i_dmiSmoothing))
        
// Check conditions per timeframe
bool dmibuyCond15m = dip15m > din15m and dip15m >= 25
bool dmisellCond15m = dip15m > din15m and din15m >= 25
bool adxbuyCond15m = dip15m > din15m and adx15m >= 25
bool adxsellCond15m = dip15m < din15m and adx15m >= 25

[dip, din, adx] = dmiWrapper(i_dmiLength, i_dmiSmoothing)
dmibuyCond = conditionType == 'DMI' ? (dip > din and dip >= 25 and dmibuyCond5m and dmibuyCond15m) : true 
dmisellCond = conditionType == 'DMI' ? (din > dip and din >= 25 and dmisellCond5m and dmisellCond15m) : true
adxbuyCond = conditionType == 'ADX' ? (dip > din and adx >= 25 and adxbuyCond5m and adxbuyCond15m) : true
adxsellCond = conditionType == 'ADX' ? (dip < din and adx >= 25 and adxbuyCond5m and adxbuyCond15m) : true

// ===== ENTRY SIGNALS ===== //
// Existing signal definitions
buySignal = TASCbuyCondition and dmibuyCond and adxbuyCond and can_trade_today and time_sess_good and strategy.position_size == 0
sellSignal = TASCsellConditon and dmisellCond and adxsellCond and can_trade_today and time_sess_good and strategy.position_size == 0


// Save stops & targets
var float longStop = na
var float shortStop = na
var float longTarget1 = na
var float shortTarget1 = na
var float longTarget2 = na
var float shortTarget2 = na
var float tradeSize = na

// Strategy execution
if buySignal 
    strategy.entry("Long", strategy.long, qty=i_contracts)
    longStop := na
    longTarget1 := na
    longTarget2 := na

if sellSignal
    strategy.entry("Short", strategy.short, qty=i_contracts)
    shortStop := na
    shortTarget1 := na
    shortTarget2 := na

// Handle long stops & target calculation
if strategy.position_size > 0 and na(longStop)
    longStop := strategy.position_avg_price - i_slPoints
    longTarget1 := strategy.position_avg_price + i_tp1_pts
    longTarget2 := strategy.position_avg_price + i_tp2_pts
    tradeSize := strategy.position_size
    strategy.exit(id="Long Exit #1",  from_entry="Long",  limit=longTarget1, stop=longStop, qty = i_contracts/2)
    strategy.exit(id="Long Exit #2",  from_entry="Long",  limit=longTarget2, stop=longStop, qty_percent=100)

// Handle short stops & target calculation
if strategy.position_size < 0 and na(shortStop)
    shortStop := strategy.position_avg_price + i_slPoints
    shortTarget1 := strategy.position_avg_price - i_tp1_pts
    shortTarget2 := strategy.position_avg_price - i_tp2_pts
    tradeSize := strategy.position_size
    strategy.exit(id="Short Exit #1", from_entry="Short", limit=shortTarget1, stop=shortStop, qty = i_contracts/2)
    strategy.exit(id="Short Exit #2", from_entry="Short", limit=shortTarget2, stop=shortStop, qty_percent=100)

if not can_trade_today
    strategy.close_all("Daily PNL limits exceeded")

/// Handle breakeven after partial exit
if strategy.position_size ==  i_contracts/2 // Long position
    longStop := strategy.position_avg_price + i_breakeven_pts
    strategy.exit(id="Long Exit #2",  from_entry="Long",  limit=longTarget2, stop=longStop, qty_percent=100)
    longTarget1 := na
else if strategy.position_size == -i_contracts/2 // Short position
    shortStop := strategy.position_avg_price - i_breakeven_pts
    strategy.exit(id="Short Exit #2", from_entry="Short", limit=shortTarget2, stop=shortStop, qty_percent=100)
    shortTarget1 := na

// Handle Breakeven after market move to a certain points
if i_market_mv_to_BE
    if high >= strategy.position_avg_price + i_pts_to_BE
        longStop := strategy.position_avg_price + i_breakeven_pts
        strategy.exit(id="Long Exit #1",  from_entry="Long",  limit=longTarget1, stop=longStop, qty = i_contracts/2)
        strategy.exit(id="Long Exit #2",  from_entry="Long",  limit=longTarget2, stop=longStop, qty_percent=100)
    else if low <= strategy.position_avg_price - i_pts_to_BE
        strategy.exit(id="Short Exit #1", from_entry="Short", limit=shortTarget1, stop=shortStop, qty = i_contracts/2)
        strategy.exit(id="Short Exit #2", from_entry="Short", limit=shortTarget2, stop=shortStop, qty_percent=100)

// Reset tradeSize when position is closed
if strategy.position_size == 0
    tradeSize := na

// Plot entry markers
plotshape(buySignal, title="Buy Signal", text="BUY", 
  style=shape.labelup, location=location.belowbar, 
  color=color.new(color.green, 0), textcolor=color.white, size=size.small)

plotshape(sellSignal, title="Sell Signal", text="SELL", 
  style=shape.labeldown, location=location.abovebar, 
  color=color.new(color.red, 0), textcolor=color.white, size=size.small)

// Draw stops & targets
plot(strategy.position_size > 0 ? longStop : na,   color=color.red,   style=plot.style_linebr, title="Stop Loss")
plot(strategy.position_size > 0 ? longTarget1 : na, color=color.green, style=plot.style_linebr, title="Long Profit Target 1")
plot(strategy.position_size > 0 ? longTarget2 : na, color=color.green, style=plot.style_linebr, title="Long Profit Target 2")

plot(strategy.position_size < 0 ? shortStop : na,   color=color.red,   style=plot.style_linebr, title="Stop Loss")
plot(strategy.position_size < 0 ? shortTarget1 : na, color=color.green, style=plot.style_linebr, title="Short Profit Target 1")
plot(strategy.position_size < 0 ? shortTarget2 : na, color=color.green, style=plot.style_linebr, title="Short Profit Target 2")


// ===== CREATE DMI/ADX DISPLAY TABLE ===== //
// var table dmiTable = table.new(position.top_right, 5, 4, border_width=1, bgcolor=color.rgb(33, 40, 48))

// // Initialize table on first bar
// if barstate.isfirst
//     // Headers
//     table.cell(dmiTable, 0, 0, "TF", bgcolor=color.gray, text_color=color.white)
//     table.cell(dmiTable, 1, 0, "+DI", bgcolor=color.gray, text_color=color.white)
//     table.cell(dmiTable, 2, 0, "-DI", bgcolor=color.gray, text_color=color.white)
//     table.cell(dmiTable, 3, 0, "ADX", bgcolor=color.gray, text_color=color.white)
//     table.cell(dmiTable, 4, 0, "Signal", bgcolor=color.gray, text_color=color.white)
    
//     // Initialize all cells (required for updates)
//     for row = 1 to 3
//         table.cell(dmiTable, 0, row, "")
//         table.cell(dmiTable, 1, row, "")
//         table.cell(dmiTable, 2, row, "")
//         table.cell(dmiTable, 3, row, "")
//         table.cell(dmiTable, 4, row, "")

// // Update DMI values for 1m timeframe
// table.cell_set_text(dmiTable, 0, 1, "1m")
// table.cell_set_text(dmiTable, 1, 1, str.tostring(dip, "#.##"))
// table.cell_set_text(dmiTable, 2, 1, str.tostring(din, "#.##"))
// table.cell_set_text(dmiTable, 3, 1, str.tostring(adx, "#.##"))

// // Color coding for +DI/-DI
// plusDIcolor = dip >= din ? color.lime : color.silver
// minusDIcolor = din > dip ? color.red : color.silver
// adxColor = adx >= 25 ? color.orange : color.silver

// table.cell_set_text_color(dmiTable, 1, 1, plusDIcolor)
// table.cell_set_text_color(dmiTable, 2, 1, minusDIcolor)
// table.cell_set_text_color(dmiTable, 3, 1, adxColor)

// signal = 
//   dip >= 25 and dip > din ? "Bull" : 
//   din >= 25 and din > dip ? "Bear" : "Neutral"
// table.cell_set_text(dmiTable, 4, 1, signal)
// table.cell_set_text_color(dmiTable, 4, 1, signal == "Bull" ? color.lime : signal == "Bear" ? color.red : color.gray)

// // Update DMI values for 5m timeframe
// table.cell_set_text(dmiTable, 0, 2, "5m")
// table.cell_set_text(dmiTable, 1, 2, str.tostring(dip5m, "#.##"))
// table.cell_set_text(dmiTable, 2, 2, str.tostring(din5m, "#.##"))
// table.cell_set_text(dmiTable, 3, 2, str.tostring(adx5m, "#.##"))

// plusDIcolor5 = dip5m >= din5m ? color.lime : color.silver
// minusDIcolor5 = din5m > dip5m ? color.red : color.silver
// adxColor5 = adx5m >= 25 ? color.orange : color.silver

// table.cell_set_text_color(dmiTable, 1, 2, plusDIcolor5)
// table.cell_set_text_color(dmiTable, 2, 2, minusDIcolor5)
// table.cell_set_text_color(dmiTable, 3, 2, adxColor5)

// signal5 = 
//   dip5m >= 25 and dip5m > din5m ? "Bull" : 
//   din5m >= 25 and din5m > dip5m ? "Bear" : "Neutral"
// table.cell_set_text(dmiTable, 4, 2, signal5)
// table.cell_set_text_color(dmiTable, 4, 2, signal5 == "Bull" ? color.lime : signal5 == "Bear" ? color.red : color.gray)

// // Update DMI values for 15m timeframe
// table.cell_set_text(dmiTable, 0, 3, "15m")
// table.cell_set_text(dmiTable, 1, 3, str.tostring(dip15m, "#.##"))
// table.cell_set_text(dmiTable, 2, 3, str.tostring(din15m, "#.##"))
// table.cell_set_text(dmiTable, 3, 3, str.tostring(adx15m, "#.##"))

// // Color coding for +DI/-DI
// plusDIcolor15 = dip15m >= din15m ? color.lime : color.silver
// minusDIcolor15 = din15m > dip15m ? color.red : color.silver
// adxColor15 = adx15m >= 25 ? color.orange : color.silver

// table.cell_set_text_color(dmiTable, 1, 3, plusDIcolor15)
// table.cell_set_text_color(dmiTable, 2, 3, minusDIcolor15)
// table.cell_set_text_color(dmiTable, 3, 3, adxColor15)

// // Signal status for 15m
// signal15 = 
//   dip15m >= 25 and dip15m > din15m ? "Bull" : 
//   din15m >= 25 and din15m > dip15m ? "Bear" : "Neutral"
// table.cell_set_text(dmiTable, 4, 3, signal15)
// table.cell_set_text_color(dmiTable, 4, 3, signal15 == "Bull" ? color.lime : signal15 == "Bear" ? color.red : color.gray)

// Debugging
plotchar(dip, 'dip', " ")
plotchar(dip5m, 'dip5m', " ")
plotchar(dip15m, 'dip15m', " ")

plotchar(din, 'din', " ")
plotchar(din5m, 'din5m', " ")
plotchar(din15m, 'din15m', " ")

plotchar(adx, 'adx', " ")
plotchar(adx5m, 'din5m', " ")
plotchar(adx15m, 'din15m', " ")

plotchar(dmibuyCond ? 1 : 0, 'DMI buy Condition', " ")
plotchar(dmisellCond ? 1 : 0, 'DMI sell Condition', " ")
plotchar(TASCbuyCondition ? 1 : 0, 'TASC Buy Entry Signal', " ")
plotchar(TASCsellConditon ? 1 : 0, 'TASC Sell Entry Signal', " ")
plotchar(adxbuyCond ? 1 : 0, 'ADX buy Condition', " ")
plotchar(adxsellCond ? 1 : 0, 'ADX sell Condition', " ")
